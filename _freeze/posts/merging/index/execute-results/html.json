{
  "hash": "29257996e2780931077f7fe315c9882c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Merging macro-level data\"\nauthor: \"Carlo Knotz\"\nbibliography: /Users/carloknotz/Documents/BibDesk_library/library.bib\ndraft: true\nformat:\n  html:\n    toc: true\n    toc-depth: 4\ndate: \"2025-06-15\"\nlightbox: true\nlang: en\ncategories:\n  - Macro\n  - UCDP\n  - Quality of Government\n  - Comparing countries\n  - Peace & conflict\n  - Merging data\neditor_options: \n  chunk_output_type: console\n---\n\n::: {.cell}\n\n:::\n\n\n\n## 1 + 1 = more\n\nBeing able to combine or merge different datasets is a critical skill for any (social, political, or economic) data analyst because, more often than not, the variables you need for your analysis are spread over different datasets. For example, many available datasets from peace & conflict research on fatalities related to wars and other types of conflict (as looked at in [this post](https://cknotz.github.io/getstuffdone_blog/posts/conflict/)) contain just that -- information about conflicts and their intensity. What they do not contain is variables that could potentially *explain* the incidence and intensity of conflicts, for example how democratic countries are [@Maoz1993;@Oneal1997], which is available in other types of datasets [e.g., @Lindbergetal2014;@Boixetal2013]. Only if you are able to merge these different datasets into one are you able to do any kind of analysis to see if your variables of interest are related with each other.\n\nFortunately, merging datasets is not as difficult as it perhaps seems -- functions like `merge()` from `base R` or `left_join()` and the other joining functions from `dplyr()` take care of most of the work [see also @Urdinez2020, chapter 11.2]. You as the data analyst in charge really only need to take care of two things:\n\n1. You need to understand the structure of your datasets and how each observation is identifed with one or more variables.\n2. You need to make sure that these identifying variables are identical in each of the datasets you want to merge.\n\nLet's make this more concrete by looking at a type of dataset that has a relatively intuitive structure: macro-level or *time series cross-sectional* (TSCS) datasets (as introduced [here](https://cknotz.github.io/getstuffdone_blog/posts/compa_countries/)). These datasets typically look more or less like this:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 Ã— 3\n  cname  ccodealp  year\n  <chr>  <chr>    <dbl>\n1 Norway NOR       1994\n2 Norway NOR       1995\n3 Norway NOR       1996\n4 Sweden SWE       1994\n5 Sweden SWE       1995\n6 Sweden SWE       1996\n```\n\n\n:::\n:::\n\n\n\nEach observation is a country-year (e.g., Norway in 1994, Norway in 1995, etc.) and we have those for multiple countries and multiple years. \n\nImportantly, this means that each observation in such a dataset is uniquely identified by a *combination* of country *and* year. There are several observations from Norway and several from 1994, so neither the `cname` variable nor the `year` variable above uniquely identify each observation by itself -- we always need both of them together to be able to tell what a given observation corresponds to. This also means that we can only directly merge datasets that both have this type of structure, and we usually need to tell `R` explicitly that this is how the datasets are structured and that the country and year variables are the ones that connect each observation in each dataset.\n\nAnother complication that often occurs is that countries are named differently. For example the United States are *\"United States\"* in one dataset but *\"United States of America\"* in another and *\"USA\"* in a third dataset. The same often applies to the United Kingdom, or South Korea. To solve this problem, people have developed standardized country codes or abbreviations like the ISO two- or three-letter country abbreviations (`NOR` or `NO`) that are identical in how they are spelled across languages, etc. The `ccodealp` variable, for example, shows three-letter ISO abbreviations. \n\nHowever, another problem is that datasets often contain different types of country name abbreviations or codes. One dataset might contain two-digit ISO codes and the other contains their three-digit equivalents. The `countrycode` package [@countrycode] was developed to solve this third problem. It automatically converts different types of country codes or names back and forth and is basically unvoidable when one works with different macro-level datasets.\n\nThe remainder of this post will show you how you can combine two macro-level datasets, the dataset on conflict-related fatalities since 1989 from the *Uppsala Conflict Data Program* (as used [here](https://cknotz.github.io/getstuffdone_blog/posts/conflict/)) and the *Quality of Government* Basic Dataset [@QOGB2025], an extremely useful macro-level dataset that contains a large number of variables on a wide range of aspects for many different countries since the end of World War II.^[Its larger sibling, the *QoG* Standard Dataset [@QOG2025] includes even more variables.]\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nged$ccodecow <- countrycode::countrycode(ged$country_cy,\n                         origin = \"country.name.en\",\n                         destination = \"cown\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nged %>% \n  left_join(qog, by = c(\"ccodecow\" = \"ccodecow\",\n                        \"year_cy\" = \"year\")) -> ged\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nged %>% \n  group_by(bmr_dem) %>% \n  summarise(sumdeaths = sum(cumulative_total_deaths_parties_in_orgvio_cy, na.rm = T)) %>% \n  drop_na(bmr_dem) %>% \n  ggplot(aes(x = factor(bmr_dem), y = sumdeaths)) +\n    geom_col()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nged %>% \n  group_by(ccodealp) %>% \n  summarise(sumdeaths = sum(sb_total_deaths_best_cy, na.rm = T),\n            avg_demo = mean(vdem_libdem, na.rm = T)) %>% \n  filter(sumdeaths>1000) %>% \n  ggplot(aes(x = avg_demo, y = sumdeaths)) +\n    geom_text(aes(label = ccodealp)) +\n    geom_smooth(method = \"lm\", se = F)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 3 rows containing non-finite outside the scale range\n(`stat_smooth()`).\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 3 rows containing missing values or values outside the scale range\n(`geom_text()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n## References\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}