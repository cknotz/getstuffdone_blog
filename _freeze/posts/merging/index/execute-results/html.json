{
  "hash": "91d685cf531f7e15e8b0b81d9098b0cc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Merging macro-level data\"\nauthor: \"Carlo Knotz\"\nbibliography: /Users/carloknotz/Documents/BibDesk_library/library.bib\ndraft: true\nformat:\n  html:\n    toc: true\n    toc-depth: 4\ndate: \"2025-06-15\"\nlightbox: true\nlang: en\ncategories:\n  - Macro\n  - UCDP\n  - Quality of Government\n  - Comparing countries\n  - Peace & conflict\n  - Merging data\neditor_options: \n  chunk_output_type: console\n---\n\n\n::: {.cell}\n\n:::\n\n\n## 1 + 1 = more\n\nBeing able to combine or merge different datasets is a critical skill for any (social, political, or economic) data analyst because, more often than not, the variables you need for your analysis are spread over different datasets. For example, many available datasets from peace & conflict research on fatalities related to wars and other types of conflict (as looked at in [this post](https://cknotz.github.io/getstuffdone_blog/posts/conflict/)) contain just that -- information about conflicts and their intensity. What they do not contain is variables that could potentially *explain* the incidence and intensity of conflicts, for example how democratic countries are [@Maoz1993;@Oneal1997] --- which are available in other datasets [e.g., @Lindbergetal2014;@Boix2013]. To be able to analyze these two variables, conflicts and democracy, and their relationships, you need to be able to merge the two datasets into one.\n\nFortunately, *merging datasets is not as difficult as it might seem at first sight* -- functions like `merge()` from `base R` or `left_join()` and the other joining functions from `dplyr()` take care of most of the work [see also @Urdinez2020, chapter 11.2]. You as the data analyst in charge really only need to take care of two things:\n\n1. You need to understand the structure of your datasets and which variable (or variable**s**) uniquely identity each observation.\n2. You need to make sure that these identifying variables are exactly identical in each of the datasets you want to merge.\n\nThis may sound a bit cryptic to the uninitiated, but we will go through this step by step in the remainder of this post. More specifically, we will first go over some basics (dataset structures) and a common \"snag\" one encounters when working with macro- or country-level data: different country names and country codes. After that, we will do an example merging operation with two macro-level datasets, the dataset on conflict-related fatalities since 1989 from the *Uppsala Conflict Data Program* (as used [here](https://cknotz.github.io/getstuffdone_blog/posts/conflict/)) and the *Quality of Government* Basic Dataset [@QOGB2025].\n\nI should also add that [Steven V. Miller](https://svmiller.com/) explains these things in two of his blog posts in probably a bit more detail:\n\n - [\"A Quick Tutorial on Various State (Country) Classification Systems\"](https://svmiller.com/blog/2021/01/a-tutorial-on-state-classification-systems/)\n - [\"A Quick Tutorial on Merging Data with the *_join() Family of Functions in {dplyr}\"](https://svmiller.com/blog/2021/01/a-tutorial-on-the-join-family-in-r/)\n \nDo check them out! (I saw them too late, otherwise I wouldn't have bothered writing my own, and clearly redundant, blog post...)\n\n\n## Dataset structures and identifying variables\n\n### Cross-sectional data\n\nAs you probably remember from your introductory data analysis or statistics course, datasets have different structures. Some are *cross-sectional* and contain data about a set of observations at one point in time. For example, data from the *European Social Survey* (ESS) contain information about a large number of survey respondents (observations) at a certain point in time -- these data are cross-sectional survey data. This type of dataset will look more or less like this:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n  essround  idno cntry   gndr agea\n1        7 12414    NO   Male   22\n2        7  9438    NO Female   43\n3        7 19782    NO Female   58\n4        7 18876    NO Female   22\n5        7 20508    NO   Male   84\n6        7 19716    NO   Male   62\n```\n\n\n:::\n:::\n\n\nThere are different respondents, and each of them is *uniquely identified* by their ID number (`idno` in this case). We also know that they come from Norway, were interviewed in round 7, and have different genders and ages.\n\n### Time series data\n\nThere are also datasets that follow a single observation over time -- we call these *time series* data. An example is the `airquality` dataset that is one of the \"built-in\" datasets that come with `R`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(airquality)\nhead(airquality)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Ozone Solar.R Wind Temp Month Day\n1    41     190  7.4   67     5   1\n2    36     118  8.0   72     5   2\n3    12     149 12.6   74     5   3\n4    18     313 11.5   62     5   4\n5    NA      NA 14.3   56     5   5\n6    28      NA 14.9   66     5   6\n```\n\n\n:::\n:::\n\n\nIf you look for the help file for this dataset with `?airquality`, you will learn that it contains daily air quality measurements from New York between May and September 1973.\n\nNote that the dataset contains two variables that relate to time: `Month` and `Day`. Obviously, each of these two variables by itself is useless. For example, just knowing that a measurement refers to day `2` is not helpful since the dataset covers four different months, each of which has a day `2`. Therefore, to *uniquely identify* a given measurement or observation, we need *both* variables, `Day` and `Month`.\n\n### Time series cross-sectional data\n\nThere is also a third type of dataset that, simply put, follows a group of *units* over some period of *time* (as introduced [here](https://cknotz.github.io/getstuffdone_blog/posts/compa_countries/)). This means this type of dataset combines time series and cross-sectional features, which is why we call this type of dataset a time series cross-sectional dataset (TSCS). Another commonly used term for this is *panel data*.^[While many use both terms interchangeably, it is more common to use the term *panel* when the dataset contains many observations but relatively few time points. The German *Socio-Economic Panel* (SOEP), for example, contains data for a large respondent sample (ca. 30.000 respondents per year) for up to 40 years. Here, the cross-sectional dimension is clearly dominant in terms of numbers. The term *time series cross-sectional* data is more often used for datasets that contain relatively few cross-sectional units -- for example 20 to 50 countries -- but over long periods of time. The *V-Dem* dataset [@Lindbergetal2014] would be an example here. See also Beck [-@Beck2001] for a more in-depth explanation.]\n\nVery commonly, TSCS data contain measurements of a set of *countries* over a number of *years* and will look more or less likely this:\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 Ã— 3\n  cname  ccodealp  year\n  <chr>  <chr>    <dbl>\n1 Norway NOR       1994\n2 Norway NOR       1995\n3 Norway NOR       1996\n4 Sweden SWE       1994\n5 Sweden SWE       1995\n6 Sweden SWE       1996\n```\n\n\n:::\n:::\n\n\nEach observation is a country-year (e.g., Norway in 1994, Norway in 1995, etc.) and we have those for multiple countries and multiple years. \n\nImportantly, this means that each observation in such a dataset is **uniquely identified by a *combination* of country *and* year**. There are several observations from Norway and several from 1994, so neither the `cname` variable nor the `year` variable above uniquely identify each observation by itself -- we always need both of them together to be able to tell what a given observation corresponds to. \n\nWe can always check if a variable or combination of variables uniquely identifies each observation in a dataset using the `anyDuplicated()` function from base `R`.^[See e.g., <https://stackoverflow.com/a/65603253>.] If variables uniquely identify observations, there should be no duplicates -- the function should return a `0`. \n\nFor example, to check if the observations in the small dataset above (let's assume it is called `tscs`) are uniquely identified by the `cname` variable, we run:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\ntscs %>% \n  {anyDuplicated(select(., cname)) == 0}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\nThe result is obviously that `cname` does not uniquely identify each observation since each country is observed over different years. This means we also need the `year` variable to identify each observation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntscs %>% \n  {anyDuplicated(select(., cname,year)) == 0}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n### On country names and codes\n\nThe United Kingdom is officially also referred to as the \"United Kingdom of Great Britain and Northern Ireland\", but sometimes simply as \"Great Britain\". Similar, the United States are also called \"USA\" or \"United States of America\", and the sample applies to a number of different countries (e.g., South Korea or the Netherlands). There are standardized codes that are supposed to fix this, one example being the ISO two- or three-digit country codes (where Norway would be `NO` or `NOR`) --- but there are many different country coding conventions, and they can differ in some cases as well (the United States might be called `US` in one and `USA` in another).\n\nThis can be -- and often is -- a problem when we want to merge two TSCS datasets where countries are the *units of observation*. A common case is that one dataset contains two-digit ISO codes and the other contains their three-digit equivalents. In that case, Norway would be called `NO` in dataset 1 and `NOR` in dataset 2, and `R` will think these are two different units and will not be able to merge the observations.\n\nSince this is such a common problem, Arel-Bundock, Enevoldsen, and Yetman [-@countrycode] put together the `countrycode` package that can convert different country names and codes back and forth, and which we can use to harmonize country variables across datasets. This is a very common operation we need to perform when merging two datasets.\n\nThe main function in `countrycode` is the `countrycode()` function, which has three main \"arguments\": \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncountrycode::countrycode(sourcevar, origin, destination)\n```\n:::\n\n\nIt works, simply put, by taking a variable that identifies countries in a given dataset (`sourcevar`) and transforming it from its current encoding (`origin`) to a different one (`destination`).\n\nFor example, let's say we want to convert the `ccodealp` variable in our little `tscs` practice dataset. As you can see below, the variable currently contains three-digit country codes for Norway and Sweden:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntscs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 Ã— 3\n  cname  ccodealp  year\n  <chr>  <chr>    <dbl>\n1 Norway NOR       1994\n2 Norway NOR       1995\n3 Norway NOR       1996\n4 Sweden SWE       1994\n5 Sweden SWE       1995\n6 Sweden SWE       1996\n```\n\n\n:::\n:::\n\n\nLet's say we need to convert this to its two-digit equivalent. To do this with `countrycode`, we need to specify `ccodealp` as the source variable, `iso3c` (\"ISO three-character\") as the origin encoding, and `iso2c` as the destination encoding. We can use `countrycode` directly within `mutate()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntscs %>%\n  mutate(ccode_2d = countrycode::countrycode(sourcevar = ccodealp,\n                                             origin = \"iso3c\",\n                                             destination = \"iso2c\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 Ã— 4\n  cname  ccodealp  year ccode_2d\n  <chr>  <chr>    <dbl> <chr>   \n1 Norway NOR       1994 NO      \n2 Norway NOR       1995 NO      \n3 Norway NOR       1996 NO      \n4 Sweden SWE       1994 SE      \n5 Sweden SWE       1995 SE      \n6 Sweden SWE       1996 SE      \n```\n\n\n:::\n:::\n\n\nIn a real-world case, you first need to be sure what exactly the encoding of your country variable is --- this information should be provided in the codebook for the dataset you are working with. You can then refer to the documentation for the `countrycode` package to see how you convert your existing variable into a the format you need.^[`countrycode` also contains a `data.frame` called `codelist_panel` with country and year information that takes into account that country names change over time (e.g., Germany was divided into East and West Germany before it reunified). Ideally, you use this dataset as a \"link\" when merging datasets that go far back in history (see also `?countrycode::countrycode()`).]\n\n\n::: {.cell}\n\n:::\n\n\n## Example: Merging the *Quality of Government* and *UCDP* conflict fatality datasets\n\nLet's put all of this into action and merge two real-life research datasets, the *Quality of Government* (QoG) Standard Dataset [@QOG2025] and the *Country-Year Dataset on Organized Violence within Country Borders* from the *Uppsala Conflict Data Program* (UCDP) [@Daviesetal2025;@Sundberg2013].\n\n### Import\n\nIf you want to follow along, you can download them directly from <https://www.gu.se/en/quality-government/qog-data/data-downloads/basic-dataset> (important: we use the *time series* version of the QoG dataset, not the cross-sectional one, and we download it in `Stata` `.dta` format!) and <https://ucdp.uu.se/downloads/index.html#orgviocy> (here, we download it directly in the `.RDS` format that is native to `R`).\n\nTo import the datasets, we use `read_dta()` from `haven` and `readRDS()`, respectively:\n\n::: {.cell}\n\n```{.r .cell-code}\nged <- readRDS(\"organizedviolencecy_v25_1.rds\")\nqog <- haven::read_dta(\"qog_bas_ts_jan25.dta\")\n```\n:::\n\n\n### Inspecting the data\n\nAs you can see from either the codebooks or the *Environment* tab, both datasets contain a number of different variables that measure countries and years. To keep things simple, we focus on the `country_cy` and `year_cy` variables in the UCDP dataset and the `year` and `cname` variables in the QoG dataset (wondering how to figure this out? This is why datasets have codebooks!).\n\n#### Are observations uniquely identified?\n\nLet's first check that these variables really uniquely identify each observation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqog %>% \n  {anyDuplicated(select(., cname,year)) == 0}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nged %>% \n  {anyDuplicated(select(., country_cy,year_cy)) == 0}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nThe UCDP dataset looks \"clean\", but the QoG dataset has some repeated country-year pairs. This is how we can identify these \"offending\" countries:\n\n::: {.cell}\n\n```{.r .cell-code}\nqog %>% \n  filter(duplicated(.[,c(\"cname\",\"year\")])) -> duplicates\n  \nunique(duplicates$cname)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Chile\"                                 \n[2] \"Congo (the Democratic Republic of the)\"\n[3] \"Indonesia\"                             \n[4] \"Syrian Arab Republic (the)\"            \n```\n\n\n:::\n\n```{.r .cell-code}\nrm(duplicates)\n```\n:::\n\n\nA closer inspection (the codebook is unfortunately quiet about this) that this is because one variable, `ccodecow` (more on that one comes below), is missing for half of these observations:\n\n::: {.cell}\n\n```{.r .cell-code}\nqog %>% \n  filter(cname==\"Chile\") %>% \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 Ã— 279\n  cname_qog cname  year ccodecow ccodealp ccodealp_year ccode_qog cname_year\n  <chr>     <chr> <dbl>    <dbl> <chr>    <chr>             <dbl> <chr>     \n1 Chile     Chile  1946      155 CHL      CHL46               152 Chile 1946\n2 Chile     Chile  1946       NA CHL      CHL46               152 Chile 1946\n3 Chile     Chile  1947      155 CHL      CHL47               152 Chile 1947\n4 Chile     Chile  1947       NA CHL      CHL47               152 Chile 1947\n5 Chile     Chile  1948      155 CHL      CHL48               152 Chile 1948\n6 Chile     Chile  1948       NA CHL      CHL48               152 Chile 1948\n# â„¹ 271 more variables: ccode <dbl>, ajr_settmort <dbl>, atop_ally <dbl>,\n#   atop_number <dbl>, bci_bci <dbl>, bicc_gmi <dbl>, biu_offrel <dbl+lbl>,\n#   bl_asyf <dbl>, bl_asym <dbl>, bl_asymf <dbl>, bmr_dem <dbl>,\n#   bmr_demdur <dbl>, bti_aar <dbl>, bti_acp <dbl>, bti_cdi <dbl>,\n#   bti_ci <dbl>, bti_cps <dbl>, bti_cr <dbl>, bti_ds <dbl>, bti_eo <dbl>,\n#   bti_eos <dbl>, bti_ep <dbl>, bti_ffe <dbl>, bti_foe <dbl>, bti_ij <dbl>,\n#   bti_mes <dbl>, bti_muf <dbl>, bti_pdi <dbl>, bti_pp <dbl>, bti_prp <dbl>, â€¦\n```\n\n\n:::\n\n```{.r .cell-code}\nqog %>% \n  filter(cname==\"Syrian Arab Republic (the)\") %>% \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 Ã— 279\n  cname_qog cname      year ccodecow ccodealp ccodealp_year ccode_qog cname_year\n  <chr>     <chr>     <dbl>    <dbl> <chr>    <chr>             <dbl> <chr>     \n1 Syria     Syrian Aâ€¦  1946      652 SYR      SYR46               760 Syria 1946\n2 Syria     Syrian Aâ€¦  1946      652 SYR      SYR46               760 Syria 1946\n3 Syria     Syrian Aâ€¦  1946       NA SYR      SYR46               760 Syria 1946\n4 Syria     Syrian Aâ€¦  1946       NA SYR      SYR46               760 Syria 1946\n5 Syria     Syrian Aâ€¦  1947      652 SYR      SYR47               760 Syria 1947\n6 Syria     Syrian Aâ€¦  1947      652 SYR      SYR47               760 Syria 1947\n# â„¹ 271 more variables: ccode <dbl>, ajr_settmort <dbl>, atop_ally <dbl>,\n#   atop_number <dbl>, bci_bci <dbl>, bicc_gmi <dbl>, biu_offrel <dbl+lbl>,\n#   bl_asyf <dbl>, bl_asym <dbl>, bl_asymf <dbl>, bmr_dem <dbl>,\n#   bmr_demdur <dbl>, bti_aar <dbl>, bti_acp <dbl>, bti_cdi <dbl>,\n#   bti_ci <dbl>, bti_cps <dbl>, bti_cr <dbl>, bti_ds <dbl>, bti_eo <dbl>,\n#   bti_eos <dbl>, bti_ep <dbl>, bti_ffe <dbl>, bti_foe <dbl>, bti_ij <dbl>,\n#   bti_mes <dbl>, bti_muf <dbl>, bti_pdi <dbl>, bti_pp <dbl>, bti_prp <dbl>, â€¦\n```\n\n\n:::\n\n```{.r .cell-code}\nqog %>% \n  filter(cname==\"Indonesia\") %>% \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 Ã— 279\n  cname_qog cname      year ccodecow ccodealp ccodealp_year ccode_qog cname_year\n  <chr>     <chr>     <dbl>    <dbl> <chr>    <chr>             <dbl> <chr>     \n1 Indonesia Indonesia  1950      850 IDN      IDN50               360 Indonesiaâ€¦\n2 Indonesia Indonesia  1950       NA IDN      IDN50               360 Indonesiaâ€¦\n3 Indonesia Indonesia  1951      850 IDN      IDN51               360 Indonesiaâ€¦\n4 Indonesia Indonesia  1951       NA IDN      IDN51               360 Indonesiaâ€¦\n5 Indonesia Indonesia  1952      850 IDN      IDN52               360 Indonesiaâ€¦\n6 Indonesia Indonesia  1952       NA IDN      IDN52               360 Indonesiaâ€¦\n# â„¹ 271 more variables: ccode <dbl>, ajr_settmort <dbl>, atop_ally <dbl>,\n#   atop_number <dbl>, bci_bci <dbl>, bicc_gmi <dbl>, biu_offrel <dbl+lbl>,\n#   bl_asyf <dbl>, bl_asym <dbl>, bl_asymf <dbl>, bmr_dem <dbl>,\n#   bmr_demdur <dbl>, bti_aar <dbl>, bti_acp <dbl>, bti_cdi <dbl>,\n#   bti_ci <dbl>, bti_cps <dbl>, bti_cr <dbl>, bti_ds <dbl>, bti_eo <dbl>,\n#   bti_eos <dbl>, bti_ep <dbl>, bti_ffe <dbl>, bti_foe <dbl>, bti_ij <dbl>,\n#   bti_mes <dbl>, bti_muf <dbl>, bti_pdi <dbl>, bti_pp <dbl>, bti_prp <dbl>, â€¦\n```\n\n\n:::\n:::\n\n\nTo keep things simple, we drop those countries:\n\n::: {.cell}\n\n```{.r .cell-code}\nqog %>% \n  filter(!(cname %in% c(\"Chile\",\"Indonesia\",\n                                        \"Syrian Arab Republic (the)\",\n                                        \"Congo (the Democratic Republic of the)\"))) -> qog\n```\n:::\n\n\nNow the `cname` and `year` variables should uniquely identify each observation:\n\n::: {.cell}\n\n```{.r .cell-code}\nqog %>% \n  {anyDuplicated(select(., cname,year)) == 0}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n#### Which countries and years are covered?\nLet's now check which time periods the two datasets cover. Starting with the conflict dataset, we get:\n\n::: {.cell}\n\n```{.r .cell-code}\nmin(ged$year_cy)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1989\n```\n\n\n:::\n\n```{.r .cell-code}\nmax(ged$year_cy)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2024\n```\n\n\n:::\n:::\n\n\nIn the case of the QoG data, we get:\n\n::: {.cell}\n\n```{.r .cell-code}\nmin(qog$year)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1946\n```\n\n\n:::\n\n```{.r .cell-code}\nmax(qog$year)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2024\n```\n\n\n:::\n:::\n\n\nBoth datasets end in 2024, but the UCPD conflict dataset covers only the period after the fall of the Berlin Wall while the QoG dataset goes back to the year after World War II. \n\nTo make the datasets more compatible, we can now drop the years prior to 1989 from the QoG dataset:\n\n::: {.cell}\n\n```{.r .cell-code}\nqog %>%\n  filter(year>=1989) -> qog\n```\n:::\n\n\nWe can now, theoretically, check which countries are covered by each dataset with `unique()`, but this results in long lists of countries. To make this easier, we can start by looking at the number of countries in each dataset:\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(unique(ged$country_cy))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 199\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(unique(qog$cname))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 197\n```\n\n\n:::\n:::\n\n\nThe UCPD dataset covers two more countries than the QoG dataset.\n\nWe can also see more in detail which countries (or, perhaps, country *names*) are included only in one but not in both datasets. To do that, we can use the `setdiff()` function from base `R`, which shows for any two vectors the items that are contained in one but not the other. \n\nImportant: We need to use this twice so we see which countries are covered in the UCDP dataset but not the QoG data, and vice versa. We start with the countries in the UCDP data that are not also in the QoG dataset:\n\n::: {.cell}\n\n```{.r .cell-code}\nsetdiff(ged$country_cy,qog$cname)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Antigua & Barbuda\"               \"Bahamas\"                        \n [3] \"Bolivia\"                         \"Bosnia-Herzegovina\"             \n [5] \"Brunei\"                          \"Cambodia (Kampuchea)\"           \n [7] \"Cape Verde\"                      \"Central African Republic\"       \n [9] \"Chile\"                           \"Comoros\"                        \n[11] \"Congo\"                           \"Czech Republic\"                 \n[13] \"DR Congo (Zaire)\"                \"Dominican Republic\"             \n[15] \"East Timor\"                      \"Federated States of Micronesia\" \n[17] \"Gambia\"                          \"Indonesia\"                      \n[19] \"Iran\"                            \"Ivory Coast\"                    \n[21] \"Kingdom of eSwatini (Swaziland)\" \"Kosovo\"                         \n[23] \"Laos\"                            \"Madagascar (Malagasy)\"          \n[25] \"Moldova\"                         \"Myanmar (Burma)\"                \n[27] \"Netherlands\"                     \"Niger\"                          \n[29] \"North Korea\"                     \"Philippines\"                    \n[31] \"Russia (Soviet Union)\"           \"Samoa (Western Samoa)\"          \n[33] \"Serbia (Yugoslavia)\"             \"South Korea\"                    \n[35] \"Syria\"                           \"Taiwan\"                         \n[37] \"Tanzania\"                        \"United Arab Emirates\"           \n[39] \"United Kingdom\"                  \"United States of America\"       \n[41] \"Vatican City State\"              \"Venezuela\"                      \n[43] \"Vietnam (North Vietnam)\"         \"Yemen (North Yemen)\"            \n[45] \"Yemen (South Yemen)\"             \"Zimbabwe (Rhodesia)\"            \n```\n\n\n:::\n:::\n\n\nThis includes, as could be expected, some of the \"usual suspects\": The UK, the US, the Netherlands, or the Koreas, which often have different names in different datasets.\n\nNext, we check which countries are covered in the QoG but not the UCDP data:\n\n::: {.cell}\n\n```{.r .cell-code}\nsetdiff(qog$cname,ged$country_cy)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Antigua and Barbuda\"                                       \n [2] \"Bahamas (the)\"                                             \n [3] \"Bolivia (Plurinational State of)\"                          \n [4] \"Bosnia and Herzegovina\"                                    \n [5] \"Brunei Darussalam\"                                         \n [6] \"Myanmar\"                                                   \n [7] \"Cambodia\"                                                  \n [8] \"Cabo Verde\"                                                \n [9] \"Central African Republic (the)\"                            \n[10] \"Taiwan (Province of China)\"                                \n[11] \"Comoros (the)\"                                             \n[12] \"Congo (the)\"                                               \n[13] \"Czechia\"                                                   \n[14] \"Dominican Republic (the)\"                                  \n[15] \"Gambia (the)\"                                              \n[16] \"Iran (Islamic Republic of)\"                                \n[17] \"CÃ´te d'Ivoire\"                                             \n[18] \"Korea (the Democratic People's Republic of)\"               \n[19] \"Korea (the Republic of)\"                                   \n[20] \"Lao People's Democratic Republic (the)\"                    \n[21] \"Madagascar\"                                                \n[22] \"Moldova (the Republic of)\"                                 \n[23] \"Netherlands (the)\"                                         \n[24] \"Niger (the)\"                                               \n[25] \"Micronesia (Federated States of)\"                          \n[26] \"Philippines (the)\"                                         \n[27] \"Timor-Leste\"                                               \n[28] \"Russian Federation (the)\"                                  \n[29] \"Serbia\"                                                    \n[30] \"Viet Nam\"                                                  \n[31] \"Zimbabwe\"                                                  \n[32] \"Yemen Democratic\"                                          \n[33] \"Sudan (the)\"                                               \n[34] \"Eswatini\"                                                  \n[35] \"United Arab Emirates (the)\"                                \n[36] \"USSR\"                                                      \n[37] \"United Kingdom of Great Britain and Northern Ireland (the)\"\n[38] \"Tanzania, the United Republic of\"                          \n[39] \"United States of America (the)\"                            \n[40] \"Venezuela (Bolivarian Republic of)\"                        \n[41] \"Samoa\"                                                     \n[42] \"Yemen\"                                                     \n[43] \"Yugoslavia\"                                                \n[44] \"Serbia and Montenegro\"                                     \n```\n\n\n:::\n:::\n\n\nThis is about the same number, and again the \"usual suspects\". Notice, for example, that Vietnam is spelled \"Viet Nam\" in the UCPD dataset. \n\nAs shown in the [earlier post](https://cknotz.github.io/getstuffdone_blog/posts/conflict/#exploring-the-ucpd-conflict-dataset), there are three countries that are covered for only very brief periods in the UCDP dataset: The German Democratic Republic (\"East Germany\"), South Yemen, and Czechoslovakia. An easy solution is -- again -- to simply drop these countries:\n\n::: {.cell}\n\n```{.r .cell-code}\nged %>% \n  filter(!(country_cy %in% c(\"German Democratic Republic\",\"Yemen (South Yemen)\",\"Czechoslovakia\"))) -> ged\n```\n:::\n\n\n#### Harmonizing the country variables\n\nSo far, we already had weed out some duplicate observations and found that, unsurprisingly, the country names differ between the two datasets. As explained earlier, we need to harmonize the country variables for the merge to work. \n\nThere are now different ways to handle this. We could either try to convert the country names in the `cname` variable in the QoG dataset to the format used in the `country_cy` variable in the UCDP dataset or vice versa. We could also try to convert both to ISO country codes and use these to merge the datasets.\n\nA third option is to use the `ccodecow` variable that is contained in the QoG dataset (the one that caused problems earlier). This variable contains standardized country codes (in the form of numbers) from the *Correlates of War* project (COW; see <https://correlatesofwar.org/>). The advantage with using this variable is that it is already contained in one of the datasets, the QoG data. More importantly, the `countrycode` package \"speaks\" COW codes, so we can use the `countrycode()` function to convert the country names in the UCDP dataset to COW codes -- and then we have everything we need in place!\n\nTo create COW country codes in the UCDP dataset, we specify that we want `countrycode()` to create a new variable called `ccodcow` in the UCDP dataset, and to do this by transforming the English country names contained in the `country_cy` variable into COW numerical codes (`cown`):\n\n::: {.cell}\n\n```{.r .cell-code}\nged$ccodecow <- countrycode::countrycode(ged$country_cy,\n                         origin = \"country.name.en\",\n                         destination = \"cown\")\n```\n:::\n\n\nWe can take a quick look at the UCDP dataset to see how the new variable looks like:^[You may notice that the COW country codes overlap with the `country_id_cy` variable -- but they are not exactly identical [see also the UCDP codebook and @Gleditsch1999].]\n\n::: {.cell}\n\n```{.r .cell-code}\nged %>% \n  relocate(country_cy,year_cy,ccodecow)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6,928 Ã— 75\n   country_cy  year_cy ccodecow country_id_cy region_cy main_govt_name_cy       \n   <chr>         <dbl>    <dbl>         <dbl> <chr>     <chr>                   \n 1 Afghanistan    1989      700           700 Asia      Government of Afghanistâ€¦\n 2 Afghanistan    1990      700           700 Asia      Government of Afghanistâ€¦\n 3 Afghanistan    1991      700           700 Asia      Government of Afghanistâ€¦\n 4 Afghanistan    1992      700           700 Asia      Government of Afghanistâ€¦\n 5 Afghanistan    1993      700           700 Asia      Government of Afghanistâ€¦\n 6 Afghanistan    1994      700           700 Asia      Government of Afghanistâ€¦\n 7 Afghanistan    1995      700           700 Asia      Government of Afghanistâ€¦\n 8 Afghanistan    1996      700           700 Asia      Government of Afghanistâ€¦\n 9 Afghanistan    1997      700           700 Asia      Government of Afghanistâ€¦\n10 Afghanistan    1998      700           700 Asia      Government of Afghanistâ€¦\n# â„¹ 6,918 more rows\n# â„¹ 69 more variables: sb_exist_cy <dbl>, sb_dyad_count_cy <dbl>,\n#   sb_dyad_ids_cy <chr>, sb_dyad_names_cy <chr>, sb_deaths_parties_cy <dbl>,\n#   sb_deaths_civilians_cy <dbl>, sb_deaths_unknown_cy <dbl>,\n#   sb_total_deaths_best_cy <dbl>, sb_total_deaths_high_cy <dbl>,\n#   sb_total_deaths_low_cy <dbl>, sb_intrastate_exist_cy <dbl>,\n#   sb_intrastate_dyad_count_cy <dbl>, sb_intrastate_dyad_ids_cy <chr>, â€¦\n```\n\n\n:::\n:::\n\n\n\n### Merging the datasets\n\nNow, after a long litany of inspection, cleaning, and harmonization, we can finally merge the datasets -- which is, as promised, a fairly quick and simple operation: We use the `left_join()` function from the `dplyr` package, which takes one dataset and then merges it with all observations from another dataset that are contained in the first one based on the variables that uniquely identify the observations in each dataset.^[There are also other types of \"mutating joins\" in `dplyr`; see <https:dplyr.tidyverse.org/reference/mutate-joins.html> for details.]\n\nThe code to do this looks as follows: We take the UCDP dataset and `left_join()` it with the QoG dataset along the `ccodecow` and `year`/`year_cy` variables and save the combined dataset as `merged`:\n\n::: {.cell}\n\n```{.r .cell-code}\nged %>% \n  left_join(qog, by = c(\"ccodecow\" = \"ccodecow\",\n                        \"year_cy\" = \"year\")) -> merged\n```\n:::\n\n\nThe new `merged` dataset contains all variables that are contained in both datasets for all observations that in the UCDP dataset that are also present in the QoG dataset. We can see this more directly by looking at the number of variables (\"columns\") per dataset:\n\n::: {.cell}\n\n```{.r .cell-code}\nncol(ged)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 75\n```\n\n\n:::\n\n```{.r .cell-code}\nncol(qog)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 279\n```\n\n\n:::\n\n```{.r .cell-code}\nncol(merged)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 352\n```\n\n\n:::\n:::\n\n\nThe number of variables in `merged` is the number of variables in `ged` plus those in `qog` minus the two variables that were used to merge the dataset (`ccodecow` and `year`/`year_cy`).\n\n## Data exploration\n\nNow that we have merged the datasets, we can do a bit of (quick and rough) data exploration to see if there is a relationship between how democratic a country is and how much conflict and violence happens in that country -- we now have information on both aspects in one common dataset, so we can see if they are related!\n\nTo measure the incidence of conflict, we use the `sb_total_deaths_best_cy` variable from the UCDP dataset, which gives the best estimate of the number of fatalities due to state-based violence within the borders of a given country and in a given year (please see the codebook for details).\n\nTo measure democratic-ness, we use to different variables from the QoG dataset:\n\n - `bmr_dem`: A binary measure of democray (democratic in a given year, yes or no) from Boix, Miller, and Rosato [-@Boix2013]\n - `vdem_libdem`: A continuous measure of liberal democracy (to what *degree* is a country a liberal democracy in a given year?) that comes originally from the *V-DEM* dataset [@Lindbergetal2014].\n \nFirst, we see if there is a difference in the average number of conflict fatalities per year in democracies and non-democracies based on the binary measure of democracy (`bmr_dem`) and visualize the result in a bar graph: \n\n::: {.cell}\n\n```{.r .cell-code}\nmerged %>% \n  group_by(bmr_dem) %>% \n  summarise(sumdeaths = sum(sb_total_deaths_best_cy, na.rm = T)) %>% \n  drop_na(bmr_dem) %>% \n  ggplot(aes(x = factor(bmr_dem), y = sumdeaths)) +\n    geom_col() +\n    scale_y_continuous(labels = scales::label_number())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\nThere clearly is a difference: Non-democracies (`bmr_dem = 0`) had on average around 800'000 fatalities per year, while the figure for democracies is slightly less than half of this. Obviously, one should not forget that conflict is overall relatively rare (see also <https://cknotz.github.io/getstuffdone_blog/posts/conflict/#conflict-fatalities-across-countries>), so these high averages are strongly driven by a few extreme cases with many fatalities. In other words, no, we obviously do not believe that Norway or Sweden had about 200'000 conflict deaths per year since 1989.\n\nWe might get a clearer picture by using the continuous measure of how liberal democratic a country is. Here, we group the data by country (using the `ccodealp` variable), calculate the average level of democratic-ness and the average number of conflict fatalities per country over the entire period of observation, and visualize the result in a scatter plot:\n\n::: {.cell}\n\n```{.r .cell-code}\nmerged %>% \n  group_by(ccodealp) %>% \n  summarise(sumdeaths = sum(sb_total_deaths_best_cy, na.rm = T),\n            avg_demo = mean(vdem_libdem, na.rm = T)) %>% \n  filter(sumdeaths>1000) %>% \n  ggplot(aes(x = avg_demo, y = sumdeaths)) +\n    geom_text(aes(label = ccodealp)) +\n    geom_smooth(method = \"lm\", se = F) +\n    scale_y_continuous(labels = scales::label_number())\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 3 rows containing non-finite outside the scale range\n(`stat_smooth()`).\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 3 rows containing missing values or values outside the scale range\n(`geom_text()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\nWe find again a negative relationship -- being more democratic is associated with fewer conflict fatalities -- but this is to a large extent driven by a few countries with very violent state-based conflicts: Ethiopia, Afghanistan, Ukraine, and (although to a lesser extent) Iraq.\n\n## Conclusion\n\nBeing able to merge two (or more) datasets is a powerful skill because it allows you to analyze relationships between variables that are contained in two separate datasets.\n\nAfter having gone through this post, you should see that the actual merging -- using `left_join()` -- is quite straightforward. You just need two datasets with overlapping observations and merge them along the variable (or variables) that uniquely identify each observation in each dataset.\n\nThe trickier thing is making sure that the datasets really are in a shape that they can be merged -- that there are overlapping variables, which do identify each observation. There is no one standard solution here since each dataset is different. Solving this requires you to have a quite intimate knowledge of each of the datasets and to be able to convert variables, where necessary. For the former, being able to do data exploration in `R` is essential, as is reading (and understanding) the datasets' codebooks. For the latter, `countrycode` is very helpful.\n\n\n## References\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}