{
  "hash": "58497c6bb33af2e70a00816249df7c30",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Measuring class with survey data\"\nauthor: \"Carlo Knotz\"\nbibliography: /Users/carloknotz/Documents/BibDesk_library/library.bib\nformat:\n  html:\n    toc: true\ndate: \"2025-03-08\"\nlightbox: true\ncategories:\n  - Survey data\n  - Class\n  - ISSP\n  - Political science\n  - Sociology\n---\n\n\n\n## Class (still) matters\n\nClass is a key concept in the social and political sciences, and it explains many important phenomena, from party preferences and voting over social attitudes to health outcomes [e.g., @Elo2009;@Gingrich2017;@Schwander2013;@Hausermannetal2022;@Evans2000]. Therefore, it is important for every empirical social and political researcher to know how to measure people's positions in class structures.\n\nSociologists have spent a lot of time on developing *class schemes* that make the abstract concept of \"class\" empirically measurable. The probably most famous class scheme is the Erikson-Goldthorpe-Portocarero (EGP) class scheme that was developed in the 1970s [@Eriksonetal1979], but there are also more recent schemes that take into account the fact that, as a result of technological change, increased educational attainment, and other factors, societies and labor markets in the 21st century look quite different than they did in the 1970s or 1980s. Daniel Oesch's [-@Oesch2006a] scheme is an important modern class scheme.\n\nThe basis for class schemes is generally **occupation** -- what job does someone have? For example, someone who is a medical doctor would typically be seen as a \"higher-skilled professional\", whereas a welder would usually be classified as a \"skilled manual worker\". People's occupations are usually measured with occupational classification schemes, the most widely used is the International Labour Organization's (ILO) *International Standard Classification of Occupations* (ISCO) scheme.^[See also <https://isco-ilo.netlify.app/en/isco-08/#download-isco-08-material>] This scheme comes in different versions reflecting the years they were adopted: ISCO-68, ISCO-88, and ISCO-08.\n\nThere are of course some people who's occupation is being **self-employed** -- they run their own businesses, which can be a small one-person business (e.g., a shop) but it can also be a medium-sized company with 500 employees. Obviously, this has effects on their class membership: A small shop owner would often be considered to be a member of the \"petite bourgeoisie\", while someone who owns a larger company might be considered a \"capital owner\".\n\n## What information do you need, and where do you get it?\n\nClass is an individual-level variable: A person can be a member of the working class, but a country cannot. This means that we use individual-level data -- survey data -- to measure class. Such survey data need to contain three pieces of information (variables) that reflect people's class membership:\n\n1. Their occupation. This needs to be measured at the *highest level of detail*, meaning with the four-digit ISCO-88 or ISCO-08 scheme. \n2. Whether or not they are self-employed.\n3. If they are self-employed, how many employees they have.\n\nMany survey datasets contain this information in some form, but it is usually easiest to use either data from large and well-known *comparative* social survey projects like the *International Social Survey Project* (ISSP) or the *European Social Survey* (ESS).^[See <https://issp.org/> and <https://www.europeansocialsurvey.org/>.] Both are free to use (but you do need to register as a user). Many national survey projects also contain that information, but occupation is often coded based on the ISCO scheme but based on national occupational classification schemes (e.g., ANZSCO for Australia and New Zealand or SOC for the United States). These can be translated to the ISCO scheme with specific *conversion tables*, but this often takes quite a bit of time and effort.\n\nTechnically speaking, applying a class scheme to survey data is quite a bit of work because you need to go over a long list of occupations -- the four-digit ISCO08 scheme contains 473 different occupations -- and decide which class they belong to. Following this, you have to write code to group all the different observations in your dataset into their classes. Obviously, this would take a lot of time.\n\nFortunately, people have written packages for `R` that make this a quick and (normally) easy thing to do. Two relevant packages are the `DIGCLASS` package, which was developed by researchers at the EU, and the `occupar` package.^[See <https://code.europa.eu/digclass/digclass> and <https://github.com/DiogoFerrari/occupar>.]\n\nThe rest of this tutorial shows how you can measure people's class with data from the ISSP and using the `DIGCLASS` package for `R`. Most of this also applies if you work with data from the ESS, but some data import and cleaning steps might be different. Below is an example of how your dataset needs to look like that you can use to guide your data cleaning and preparation when you work with the ESS.\n\n\\newpage\n## Installing the `DIGCLASS` package\n\nThe `DIGCLASS` package is not on *CRAN* (the official `R` \"app store\"), but you can install it with the `remotes`-package (which you need to have installed first, of course):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"remotes\")\nremotes::install_git(\"https://code.europa.eu/digclass/digclass.git\")\n```\n:::\n\n\n\nNext, we load the package with `library()`, in addition to the `tidyverse` package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(DIGCLASS)\ntheme_set(theme_classic())\n```\n:::\n\n\n\n\\newpage\n## Getting ISSP data\n\nIn this tutorial, we will work with data from the 2016 *Role of Government* round of the ISSP (v. 2.0.0; 19.09.2018), which you can download from the *GESIS* data repository: <https://www.gesis.org/en/issp/data-and-documentation/role-of-government/2016#c127852>. As mentioned earlier, you need to register as a user, but this is free -- and also gives you access to many other survey datasets like the *Eurobarometer* or the *European Values Study*.\n\nMake sure that you download the data in SPSS (`.sav`) format and that you store them in the folder that you are working in (ideally your *RStudio Project* folder).\n\n\n\n::: {.cell}\n\n:::\n\n\n\n## Importing the dataset\n\nTo import the dataset, you can use the `read_sav()` function from the `haven` package. **Important:** Simply import the dataset for now, do not yet convert it with `labelled::unlabelled()`! I have stored the dataset as `issp16.sav`, so I need to specify this in my code -- you obviously need to use the name that you gave your dataset file:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nissp <- haven::read_sav(\"issp16.sav\")\n```\n:::\n\n\n\nAs other large survey datasets, the ISSP dataset is very large and contains almost 400 variables:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(issp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 48720   395\n```\n\n\n:::\n:::\n\n\n\nTo make things easier for now, we trim the data to the variables we actually need plus one variable (`v19`) that we can later use as a dependent variable in an example analysis:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nissp %>% \n  select(studyno,country, # good to keep these in \n         ISCO08, # ISCO-08 occupational codes\n         EMPREL, # Employment relationship, to identify self-employed\n         NEMPLOY, # number of employees if self-employed\n         v19 # a variable measuring respondents' views on whether the government should spend more on the unemployed\n         ) -> issp\n```\n:::\n\n\n  \n\\newpage\n## Data preparation\n\nThe `DIGCLASS` package expects the data it works with to be in a specific format. If you for example call up the help file for the `DIGCLASS::isco08_to_oesch()` function with `?DIGCLASS::isco08_to_oesch` and scroll down a bit, you see that the function needs three main inputs:\n\n1. `x`, which is the four-digit ISCO-08 scores. They need to be stored as text (`character`)\n2. `self_employed`, which needs to be a \"numeric vector indicating whether each individual is self-employed (1) or an employee (0).\"\n3. `n_employees`, which needs to be a \"numeric vector indicating the number of employees under each respondent.\"\n\nThis means we need to have three variables that correspond exactly to this: ISCO-08 scores as text, a 0/1 dummy indicating whether someone is self-employed, and a variable containing the number of employees for those who are self-employed.\n\n### Preparing the ISCO-08 scores\nLet's start the data preparation with `ISCO08`, and let's first take a closer look at how it is stored now:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(issp$ISCO08)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"haven_labelled\" \"vctrs_vctr\"     \"double\"        \n```\n\n\n:::\n:::\n\n\n  \nFrom the result of `class()`, we see that the variable is stored in a `labelled`-type format -- which is because the dataset was imported with `haven` -- and this is also the case for all the other variables (see the *Environment*).\n\nTo see a bit more clearly how the `ISCO08` variable looks like, let's look at the first few observations:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nissp %>% \n  select(ISCO08) %>% \n  slice_head(n = 10) # to get first ten observations\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 1\n   ISCO08                                                               \n   <dbl+lbl>                                                            \n 1 2611 [Lawyers]                                                       \n 2 2512 [Software developers]                                           \n 3 1212 [Human resource managers]                                       \n 4 1439 [Services managers not elsewhere classified]                    \n 5 4419 [Clerical support workers not elsewhere classified]             \n 6 1345 [Education managers]                                            \n 7 3230 [Traditional and complementary medicine associate professionals]\n 8 2654 [Film, stage and related directors and producers]               \n 9 2611 [Lawyers]                                                       \n10 5131 [Waiters]                                                       \n```\n\n\n:::\n:::\n\n\n\nYou see that the first observation is a lawyer, which has the ISCO-08 code 2611, the next is a software developer (ISCO-08 code 2512), and so on.\n\n**Now comes an important step:** We need to convert the `ISCO08` variable to a character-type variable -- for some reason, the `DIGCLASS` package expects that the ISCO codes are stored as text (e.g., \"2611\", \"2512\"), and that is what we need to deliver for the package to work.\n\nTo do that, we simply use `as.character()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nissp %>% \n  mutate(isco_nums_as_text = as.character(ISCO08)) -> issp\n```\n:::\n\n\n\nThe new variable should now be a character-type variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(issp$isco_nums_as_text)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\nThis means that the ISCO-08 scores are taken care off and we can move on to the next piece of information that we need: a 0/1 variable that tells us if people are self-employed. \n\n\\newpage\n### Self-employment\n\nInformation about how people earn their living in general is contained in the `EMPREL` variable. To see how this looks like, we can quickly tabulate the individual categories:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(issp$EMPREL)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n    1     2     3     4 \n33504  4169  1797  1185 \n```\n\n\n:::\n:::\n\n\n\nUnfortunately, we only get numbers. This is because the dataset is still stored in the `labelled` format, and we can quickly fix this by using `unlabelled()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nissp <- labelled::unlabelled(issp)\n```\n:::\n\n\n\nNow the tabulation should work as intended:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(issp$EMPREL)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nNAP (Code 3 in WORK; NZ: Code 2-9 MAINSTAT) \n                                          0 \n                                   Employee \n                                      33504 \n            Self-employed without employees \n                                       4169 \n               Self-employed with employees \n                                       1797 \n          Working for own family's business \n                                       1185 \n                                  No answer \n                                          0 \n```\n\n\n:::\n:::\n\n\n\nYou see that most respondents fall into the \"Employee\" category, but there are also people who are self-employed with and without employees. Some also work in a family business. Finally, there are some empty categories that have no observations, but we ignore them for now.\n\n\\newpage\nAll we really need to do is to re-code this variable into a 0/1 dummy that is equal to 1 if people are self-employed and 0 otherwise. Here, we can use the `case_match()` function, which is simply put a more advanced version of `if_else()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nissp %>% \n  mutate(selfemp = case_match(EMPREL,\n                              c(\"Self-employed without employees\",\n                                \"Self-employed with employees\") ~ 1,\n                              c(\"Employee\",\"Working for own family's business\") ~ 0,\n                              .default = NA)) -> issp\n```\n:::\n\n\n\nMaybe you can already see that we are here telling `R` to create a new variable called `selfemp` that is 1 if the `EMPREL` variable is either \"Self-employed without employees\" or \"Self-employed with employees\" and 0 otherwise. To make sure that observations that do not fit either of these conditions are excluded, we specify `.default = NA`.\n\nWe can do a quick cross-tabulation to see if the re-coding worked as intended:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(issp$EMPREL,issp$selfemp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                                             \n                                                  0     1\n  NAP (Code 3 in WORK; NZ: Code 2-9 MAINSTAT)     0     0\n  Employee                                    33504     0\n  Self-employed without employees                 0  4169\n  Self-employed with employees                    0  1797\n  Working for own family's business            1185     0\n  No answer                                       0     0\n```\n\n\n:::\n:::\n\n\n\nIt looks like things did work: the self-employed are coded as 1, all others are 0.\n\n### Number of employees\n\nThe final variable we need is how many employees those respondents who are self-employed have. Here, we can use the `NEMPLOY` variable from the ISSP dataset, but let's again begin by simply checking what type this variable is:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(issp$NEMPLOY)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n\nThe variable is already numeric, which means we do not really have to do anything with it -- it is good to go. But we can nevertheless quickly visualize it to see how it is distributed:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nissp %>% \n  ggplot(aes(x = NEMPLOY)) +\n    geom_histogram(color = \"white\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 46996 rows containing non-finite outside the scale range\n(`stat_bin()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\nThere are a few extreme outliers which make it difficult to see anything. We can get a clearer picture by removing those with more than 100 employees from the graph (obviously, we only do this for the graph!):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nissp %>% \n  filter(NEMPLOY<100) %>% \n  ggplot(aes(x = NEMPLOY)) +\n    geom_histogram(color = \"white\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\nMost respondents who have employees have only relatively small businesses with less than 25 employees.\n\n\\newpage\n\n## Generating a class variable\n\nWe now have all pieces of information we need and can get to the class variable. Let's start by generating two of Daniel Oesch's [-@Oesch2006a] class schemes, the very simple one with five classes and the more advanced one with eight classes. Each can be generated with the `isco08_to_oesch()` function. The following code shows how to create both class schemes at once:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nissp %>% \n  mutate(oesch_5 = DIGCLASS::isco08_to_oesch(x = isco_nums_as_text,\n                                             self_employed = selfemp,\n                                             n_employees = NEMPLOY,\n                                             n_classes = 5,\n                                             label = T,\n                                             to_factor = F),\n         oesch_8 = DIGCLASS::isco08_to_oesch(x = isco_nums_as_text,\n                                             self_employed = selfemp,\n                                             n_employees = NEMPLOY,\n                                             n_classes = 8,\n                                             label = T,\n                                             to_factor = F)) -> issp\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nℹ ISCO variable has occupations with digits less than 4. Converting to 4 digits.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• Converted `110` to `0110`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• Converted `310` to `0310`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• Converted `210` to `0210`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nℹ ISCO variable has occupations with digits less than 4. Converting to 4 digits.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• Converted `110` to `0110`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• Converted `310` to `0310`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• Converted `210` to `0210`\n```\n\n\n:::\n:::\n\n\n\n\\newpage\nLet's have a look at the results:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(issp$oesch_5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n'Higher-grade service class'  'Lower-grade service class' \n                        6374                         7058 \n           'Skilled workers'      'Small business owners' \n                       12478                         1117 \n         'Unskilled workers' \n                        7558 \n```\n\n\n:::\n\n```{.r .cell-code}\ntable(issp$oesch_8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n                           '(Associate) managers' \n                                             5541 \n                                         'Clerks' \n                                             4043 \n                             'Production workers' \n                                             8309 \n'Self-employed professionals and large employers' \n                                              493 \n                                'Service workers' \n                                             7684 \n                          'Small business owners' \n                                             1117 \n            'Socio-cultural (semi-)professionals' \n                                             4667 \n                 'Technical (semi-)professionals' \n                                             2731 \n```\n\n\n:::\n:::\n\n\n\nAnd we have what we want: Two class schemes, one simpler and the other a bit more detailed. The second one is used by for example Gingrich [-@Gingrich2017] or Schwander & Häusermann [-@Schwander2013].^[Gingrich calls \"socio-cultural (semi-) professionals\" the \"new middle class\", \"technical (semi-) professionals\", \"clerks\", and \"(Associate) managers\" are the \"old middle class\", \"service workers\" are the \"new working class\", and \"Production workers\" are the \"old working class\". If you wanted, you could use `case_match()` to re-code the `oesch_5` variable into a new and simpler class scheme that corresponds to what Gingrich is using.] \n\n\\newpage\n## Example analysis\n\nLet's say we wanted to find out if people's class has an effect on how they think about the welfare state, specifically whether the government should do more to support the unemployed. As mentioned earlier, the ISSP includes a variable that measures these attitudes and which looks like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(issp$v19)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntable(issp$v19)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n             NAV (PH)       Spend much more            Spend more \n                    0                  7209                 12422 \nSpend the same as now            Spend less       Spend much less \n                16760                  6546                  2390 \n         Can't choose             No answer \n                    0                     0 \n```\n\n\n:::\n:::\n\n\n\nThe variable is stored as a factor (i.e., as a categorical variable), but it has five categories -- so we can, sort of, get away with treating it as if it were numeric [this is what @Thewissen2019 also do]. To be able to do that, we first have to check how it looks internally and then convert it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbst290::visfactor(dataset = issp,\n                  variable = \"v19\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n values                labels\n      1              NAV (PH)\n      2       Spend much more\n      3            Spend more\n      4 Spend the same as now\n      5            Spend less\n      6       Spend much less\n      7          Can't choose\n      8             No answer\n```\n\n\n:::\n:::\n\n\n\nThere is a bit of a divergence between values and labels -- the `NAV (PH)` category is empty (see above), which means the lowest *actual* category has the value of 2 and so on. We can fix this by simply using `droplevels()` to get rid of empty categories and then `as.numeric()`. \n\nOne thing we need to pay attention to is that, right now, *lower* scores correspond to *more* support for government aid to the unemployed. This is a bit strange to work with, so we reverse the scale of the new variable by subtracting it from 6 (so that the score of 1 becomes 6-1 = 5, 2 becomes 6-2 = 4, and so on:)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nissp %>% \n  mutate(v19 = droplevels(v19),\n         unemspend = 6 - as.numeric(v19)) -> issp\n```\n:::\n\n\n\nThe new numeric variable has values from 1 to 5, which is what we want:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(issp$unemspend)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n    1     2     3     4     5 \n 2390  6546 16760 12422  7209 \n```\n\n\n:::\n:::\n\n\n\nLet's now see to class influences attitudes toward help for the unemployed in Sweden (it is **important** to focus on one country alone, otherwise a simple linear regression model will give wrong results!):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nissp %>% \n  filter(country == \"SE-Sweden\") -> swe_data\n\nmod1 <- lm(unemspend ~ oesch_5,\n           data = swe_data)\nsummary(mod1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = unemspend ~ oesch_5, data = swe_data)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-2.38053 -0.38053  0.03929  0.43478  2.43478 \n\nCoefficients:\n                                   Estimate Std. Error t value Pr(>|t|)    \n(Intercept)                         2.80315    0.05211  53.793  < 2e-16 ***\noesch_5'Lower-grade service class'  0.15756    0.07196   2.190   0.0288 *  \noesch_5'Skilled workers'            0.50707    0.07234   7.010 4.56e-12 ***\noesch_5'Small business owners'     -0.23793    0.18084  -1.316   0.1886    \noesch_5'Unskilled workers'          0.57738    0.09391   6.148 1.16e-09 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.8305 on 939 degrees of freedom\n  (196 observations deleted due to missingness)\nMultiple R-squared:  0.07685,\tAdjusted R-squared:  0.07291 \nF-statistic: 19.54 on 4 and 939 DF,  p-value: 1.842e-15\n```\n\n\n:::\n:::\n\n\n\nAs always, one category (here: \"Higher-grade service class\") is omitted from the model and the coefficients show us the difference from each other class to the omitted one. This means that all classes except for small business owners are significantly more supportive of government help for the unemployed than the higher-grade service class. \n\nTo get a better sense, we can use `prediction::prediction_summary()` to get predicted support scores per class based on the model:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprediction::prediction_summary(model = mod1,\n                               at = list(oesch_5 = unique(na.omit(swe_data$oesch_5))))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                  at(oesch_5) Prediction      SE     z         p lower upper\n            'Skilled workers'      3.310 0.05017 65.98 0.000e+00 3.212 3.409\n 'Higher-grade service class'      2.803 0.05211 53.79 0.000e+00 2.701 2.905\n  'Lower-grade service class'      2.961 0.04963 59.65 0.000e+00 2.863 3.058\n          'Unskilled workers'      3.381 0.07813 43.27 0.000e+00 3.227 3.534\n      'Small business owners'      2.565 0.17317 14.81 1.202e-49 2.226 2.905\n```\n\n\n:::\n:::\n\n\n\n\\newpage\nWe can get an ever better picture of the results if we just visualize the result:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprediction::prediction_summary(model = mod1,\n                               at = list(oesch_5 = unique(na.omit(swe_data$oesch_5)))) %>% \n  ggplot(aes(x = Prediction, \n             y = reorder(`at(oesch_5)`,Prediction), \n             xmin = lower, xmax = upper)) +\n    geom_point(stat = \"identity\") +\n    geom_linerange() +\n    scale_x_continuous(breaks = seq(1,5,1),\n                       limits = c(1,5)) +\n    labs(x = \"Predicted support for government aid to the unemployed\",\n         y = \"Class\", caption = \"95% confidence intervals\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n\nNote that we use `reorder()` to arrange the classes from highest to lowest support. Clearly, small business owners in Sweden are least supportive of government help for the unemployed, while unskilled and skilled workers (i.e., the \"working class\") are most supportive. Looks like class does still matter in Sweden!\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}